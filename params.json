{
  "name": "Dvalin",
  "tagline": "Taimos microservices framework",
  "body": "[![Build Status](https://travis-ci.org/taimos/dvalin.svg)](https://travis-ci.org/taimos/dvalin)\r\n[![codecov.io](https://codecov.io/github/taimos/dvalin/coverage.svg?branch=master)](https://codecov.io/github/taimos/dvalin?branch=master)\r\n\r\n# dvalin - Taimos Microservice Framework\r\n\r\nDvalin is a Java micro service framework based on several open-source frameworks to combine the best tools into one quick start suite for fast, reliable and scaling micro services.\r\nThe core technology is the Spring framework and dvalin uses our Daemon Framework as the lifecycle management for the service process.\r\n\r\nTo use dvalin in your project add the maven dependencies as shown below. \r\nIt is recommended to set the dvalin version as property to make sure all modules you use have the same version.\r\n\r\n```\r\n<dependency>\r\n    <groupId>de.taimos</groupId>\r\n    <artifactId>dvalin-MODULE</artifactId>\r\n    <version>${dvalin.version}</version>\r\n</dependency>\r\n```\r\n\r\nThen add dvalin as a BOM to the maven dependency management to ensure compatibly versions of used third-party libraries.\r\n\r\n```\r\n<dependencyManagement>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>de.taimos</groupId>\r\n            <artifactId>dvalin-parent</artifactId>\r\n            <version>${dvalin.version}</version>\r\n            <type>pom</type>\r\n            <scope>import</scope>\r\n        </dependency>\r\n    </dependencies>\r\n</dependencyManagement>\r\n```\r\n \r\n# Parts of dvalin\r\n \r\nDvalin provides several independent but combineable libraries serving different purposes around the runtime and \r\ninteraction of micro services. By adding a library as a Maven dependency, it gets activated automatically and \r\nall the needed Spring components are started.\r\n\r\nThese libraries are:\r\n\r\n* `daemon` - the core library for lifecycle and basic Spring enhancements\r\n* `jaxrs`- implement JAX-RS based REST services using the Apache CXF framework\r\n* `jpa` - connect to SQL databases using the popular Hibernate framework\r\n* `mongodb` - connect to MongoDB document store\r\n* `dynamodb`- connect to AWS DynamoDB data storage\r\n* `cloud` - basic tools to communicate with Cloud providers\r\n* `cluster` - basic tools to form a cluster\r\n* `template` - templating functionality\r\n* `notification` - notification service to send e-mails and use template engines\r\n* `monitoring` - monitoring service to report statistics of your service\r\n* `interconnect` - communication framework to connect micro services with each other\r\n* `test` - utilities for writing tests\r\n\r\n## daemon\r\n\r\nThe `daemon` part includes the Taimos daemon framework into dvalin. You can use the following conditional annotations from the daemon framework:\r\n\r\n* `@BeanAvailable` - Only create the annotated bean if the denoted bean is also available\r\n* `@OnSystemProperty` - Only create the annotated bean if the denoted system property is set and if it optionally also has the given value\r\n\r\nThe entry point for your application is the `DvalinLifecycleAdapter`. Just extend it and implement a main method that calls the static `start` method. \r\nThis configures your application to read properties from a file called `dvalin.properties`.\r\n\r\nBy overriding the `setupLogging()` Method you can enable the `StructuredLogConfigurer` instead of the default Log4j configuration. \r\nLogging will the use the console and print all entries in JSON format. The `DvalinLogger` can be used to modify the MDC for a single log line.\r\n\r\n## jaxrs\r\n\r\nThe `jaxrs` library adds tooling to implement JAX-RS web services. It combines the powers of the Spring framework, \r\nthe Apache CXF framework, the Jackson JSON mapper and the Eclipse Jetty web server. To include it add the maven dependency to your POM file.\r\nIt will then automatically configure a Jetty web server running on a given port and start a CXF JAX-RS handler into the running Jetty server. \r\nBy default all beans annotated with `@JaxRsComponent` will be registered as provider or endpoint respectively. \r\nAdditionally several extra features are implemented.\r\n\r\nYou can inject the `DvalinRSContext` to get easier access to some of the features.  \r\n\r\n### Monitoring\r\n\r\nFor every request an instance of `de.taimos.dvalin.jaxrs.monitoring.InvocationInstance` will be registered into the MessageContext. \r\nIt will contain a unique request id and will measure the runtime of the request for monitoring purpose.\r\n\r\n### Providers\r\n\r\nYou can activate preconfigured JacksonProvider or WebExceptionMapper by subclassing the respective type and annotate it with `@JaxRsComponent`.\r\n\r\n### Remote service\r\n\r\nBy annotating a private field of a JAX-RS client interface with `@RemoteService` dvalin will automatically create a JAX-RS client \r\nproxy and then inject it like any other autowired bean into the desired location. You can provide the base URL of the service \r\nor use defined system properties to resolve the URL of the service.\r\n\r\n### Swagger\r\n\r\nThe JAX-RS web service it automtically documented using the Swagger specification and published as `swagger.{json|yaml}` on the\r\nroot of your API URL. Also a graphical Swagger ui is served under `/swagger-ui`.\r\n\r\n### WebSocket support\r\n\r\nYou can publish a WebSocket just by annotating any class with `@WebSocket`. If you like you can use the \r\nabstract `ServerJSONWebSocketAdapter` as a base class. For the client side (e.g. in tests) you can use the `ClientSocketAdapter` \r\nto connect the the published socket.\r\n\r\n### Security\r\n\r\nThere are several helper classes and beans to provide identity and access management functionality. \r\n\r\n#### Authentication\r\n\r\nYou can subclass the abstract `AuthorizationProvider` and return SecurityContexts in the methods to \r\nimplement or you can provide implementations of predefined bean interfaces to activate ready-to-use \r\nauthentication filters for BasicAuth or token based authentication.\r\n\r\nThese interfaces are the `IBasicAuthUserDAO` or the `ITokenAuthUserDAO`. If you put an implementation \r\nin your Spring context the JAX-RS filter will be deployed using the `@BeanAvailable` annotation of the core library.\r\n\r\n#### Authorization\r\n\r\nTo limit access to sensitive resources you can use the injectable `DvalinRSContext` that provides methods to retrieve \r\ninformation about the logged in user or to assert given roles. Additionally dvalin registers filters that \r\nsupport the following annotations to limit access to resources.\r\n\r\n* `@RolesAllowed` - only users having at least one of the provided roles are granted access\r\n* `@LoggedIn` - only request that contain a valid logged in user are processed\r\n\r\nTo help in protecting user credentials the class `HashedPassword` implements everything needed to store \r\npassword hashes secured by the SHA-512 function using a 512 bit salt and a dynamic number of iterations.\r\n\r\n### Configuration\r\n\r\nSeveral settings of the dvalin framework can be customized using system properties which are described \r\nin `de.taimos.dvalin.jaxrs.SpringCXFProperties`.\r\n\r\n### Testing\r\n\r\nFor integration tests of your JAX-RS service there are several helpers implemented in dvalin. There \r\nis an abstract `APITest` class that provides several helper methods to start web requests, open web sockets\r\nand assert responses from web service endpoints. To assert conditions across multiple threads you can use \r\nthe AsyncAssert class. To inject client proxies to your API under test just annotate a field in your test \r\nclass with `@TestProxy` and dvalin will create the desired proxy and link it to the server instance during test execution.  \r\n\r\n### JSON Web Tokens\r\n\r\nFor Web Token support include the additional dependency `dvalin-jaxrs-jwtauth` and set the following properties:\r\n\r\n* `jwtauth.issuer` - the issuer of the tokens\r\n* `jwtauth.secret` - the shared secret to sign web tokens with\r\n* `jwtauth.timeout` - optional timeout of the tokens (defaults to one hour)\r\n\r\nYou can then create WebTokens using the `JWTAuth` bean and they are automatically validated when set as Bearer type Authorization.\r\n\r\n## jpa\r\n\r\nThe `jpa` library adds JPA and Hibernate support including changeset management using liquibase. By setting some \r\nsystem properties you get the full support to store and retrieve data from relational database systems. \r\nSupported databases are currently HSQL, PostgreSQL and MySQL. You have to add the desired jdbc driver to your classpath manually.\r\n\r\nThe following settings are possible:\r\n\r\n* `ds.type` - {MYSQL|POSTGRESQL|HSQL} type of the database\r\n* `ds.package` - root package of your entities (path notation with /)\r\n* `ds.showsql` - {true|false} to log all SQL statements to the logger\r\n* `ds.demodata` - {true|false} to insert data from the file `sql/demodata_${ds.type}.sql` on startup\r\n\r\nFor MySQL the following extra setting are possible:\r\n\r\n* `ds.mysql.host` - the hostname of the database server\r\n* `ds.mysql.port` - the port number of the database server\r\n* `ds.mysql.db` - the name of the database\r\n* `ds.mysql.user` - the user name of the database server\r\n* `ds.mysql.password` - the password of the database server\r\n\r\nFor PostgreSQL the following extra setting are possible:\r\n\r\n* `ds.pgsql.host` - the hostname of the database server\r\n* `ds.pgsql.port` - the port number of the database server\r\n* `ds.pgsql.db` - the name of the database\r\n* `ds.pgsql.user` - the user name of the database server\r\n* `ds.pgsql.password` - the password of the database server\r\n\r\nThe library also provides a general purpose DAO interface (`IEntityDAO`) and an abstract implementation\r\n(`EntityDAOHibernate`) with many helper methods to ease the development of the data layer. For this to \r\nwork your entities have to implement the `IEntity` interface.\r\n\r\nIf you use the JodaTime library you can annotate Date members with the `JodaDateTimeType` to activate \r\nJodaTime support for JPA.\r\n\r\nAll changesets contained or referenced in the file `liquibase/changelog.xml` are checked and applied \r\non startup by the liquibase database migration library.\r\n\r\n## mongodb\r\n\r\nThe mongodb library adds support for the MongoDB document store. By adding the dependency you get the \r\nfull support to interact with MongoDB databases including an in-memory database for tests. \r\n\r\n### Connection properties\r\n\r\nThe following settings are possible:\r\n\r\n* `mongodb.type` - {fake|real} connect to real MongoDB database or in-memory version using `Fongo`\r\n* `mongodb.name` - the name of the database to use for data storage\r\n* `mongobee.enabled` - {true|false} use mongobee for database migration\r\n* `mongobee.basePackage` - the base package of the Mongobee changesets\r\n* `mongodb.demodata` - {true|false} load demodata on startup from ND-JSON files\r\n\r\nFor connections to real MongoDB databases, these extra properties can be set:\r\n\r\n* `mongodb.host` - the host of the MongoDB instance (default: localhost)\r\n* `mongodb.port` - the port of the MongoDB instance (default: 27017)\r\n* `mongodb.uri` - instead of host and port you can specify the complete connection string\r\n* `mongodb.socketTimeout` - the socket timeout of the connection (default: 10 seconds)\r\n* `mongodb.connectTimeout` - the connection timeout of the connection attempt (default: 10 seconds)\r\n\r\n\r\n### Abstract entity and DAO interface\r\n\r\nThe library provides a general purpose DAO interface (`ICrudDAO`) and an abstract implementation\r\n(`AbstractMongoDAO`) with many helper methods to ease the development of the data layer. For this to \r\nwork your entities have to extend the `AEntity` superclass. The DAOs created have integrated support \r\nfor JodaTime classes. If you want to use polymorphic types in your entities make sure to implement \r\n`@IMappedSupertype` on the super class. This advises the Jackson mapper to include type information \r\ninto the created JSON for deserialization. \r\n\r\n### Changesets\r\n\r\nFor database migration purpose the mongobee library is included and is configured as denoted above \r\nusing system properties. See the mongobee documentation on how to implement changesets. \r\nFor Index creation take a look at the `ChangelogUtil` helper class.\r\n\r\n### MongoDBInit\r\n\r\nTo prefill the database with startup data or test data for integration tests put file on your classpath \r\ninto the package `mongodb` and name them using the following pattern: `<CollectionName>.ndjson`\r\nIf you set the system property `mongodb.demodata`to `true` dvalin will populate the given collections \r\nwith the objects contained in this new-line delimited files. Just put one JSON object per line. \r\n\r\n### DocumentLinks\r\n\r\nAnother feature of dvalin's MongoDB support are DocumentLinks. These allow for references between your \r\ndocuments. To include a reference in one of your entities just add a field of the generic type \r\n`DocumentLink` and let your referenced entity extend `AReferenceableEntity` instead of `AEntity`. \r\nDvalin will then include a reference to the given document in your JSON which you can resolve \r\nby injecting the `IDlinkDAO` wherever you want.\r\n\r\n## dynamodb\r\n\r\nThe dynamodb library adds support for the AWS DynamoDB data store. By including the AWS cloud module you \r\nget the full support to interact with DynamoDB using the SDK or the DynamoDBMapper.\r\n\r\n### Abstract DAO implementation\r\n\r\nThe library provides a general purpose DAO implementation (`AbstractDynamoDAO`) with automatic initialization\r\nand table creation. If you set the `dynamodb.url` property the endpoint of the SDK is reconfigured. This \r\nenables the use of the local DynamoDB version for development.\r\n\r\n## cloud\r\n\r\nThe `cloud` libraries provide SDKs for cloud service providers. Currently only Amazon Web Services \r\nis available under `cloud-aws` and can be added using maven. It provides the core dependency to the \r\nJava AWS SDK and the annotation `@AWSClient` to inject clients to access the AWS API. Just annotate \r\na member extending `AmazonWebServiceClient` and dvalin will automatically inject a configured instance into your bean.\r\n\r\nRegion selection occurs as follow:\r\n\r\n* If present the `region` value of the annotation is evaluated as Spring expression\r\n* If present the property `aws.region` is used\r\n* If present the environment variable `AWS_DEFAULT_REGION` is used\r\n* If present the environment variable `AWS_REGION` is used\r\n* If running on an EC2 instance the current region is used\r\n* The SDK's default region is used\r\n\r\nIf `aws.accessKeyId` and `aws.secretKey` are present as properties they will be used to sign the requests\r\nto the AWS API. Otherwise the following chain will be used:\r\n\r\n* Use environment variables\r\n* Use system properties\r\n* Use profile information\r\n* Use EC2 instance profile\r\n\r\n### Utility beans\r\n\r\nThere are two utility beans that implement common use cases in EC2 and CloudFormation. \r\nSee `EC2Context` and `CloudFormation` beans for details.\r\n\r\nIn addition you can let Dvalin signal the current CloudFormation stack by setting \r\nthe property `aws.cfnsignal` to `true`.\r\n\r\n## cluster\r\n\r\nThe `cluster` libraries provide tools to form a cluster of services. Currently only Hazelcast is available \r\nunder `cluster-hazelcast` and can be added using maven. It adds hazelcast to the classpath and auto configuration for clusters.\r\nTo form a cluster set the system property `hazelcast.cluster` to `true` and implement `ClusterInfoProvider` as a component.\r\nTo connect to a cluster implement the same interface and set the property `hazelcast.client` to the name \r\nof a cluster that the provider can resolve.\r\n\r\n## templating\r\n\r\nThis component provides a templating engine based on Velocity and PDF generation based on XDocReport.\r\n\r\n### Template engine\r\n\r\nFor templating the Velocity template engine is used. Inject the `ITemplateResolver` in your bean to process \r\ntemplates. You can provide a location relative to the folder `/velocity` in your classpath or you provide \r\nthe template as String.\r\n\r\n### PDF generation\r\n\r\nFor PDF generation XDocReport is used. Inject the `ReportService` tp create PDF files. You provide a location \r\nrelative to the folder `/xdocreport` in your classpath targetting a docx file. This file is then merged \r\nwith the given context and a PDF is created. \r\n\r\n## notification\r\n\r\nThe notification component provides support for sending e-mails. The `notification-aws` \r\nlibrary provides an implementation of the `MailSender` that uses Amazon SimpleEmailService.\r\n\r\n### E-Mail\r\n\r\nDvalin uses the standard Spring MailSender interface for its email support. The core library provides the \r\n`TestMailSender` that stores the sent mails into a collection instead of sending them out. This can be \r\nused in integration tests. The `notification-aws` version uses SES to send emails. The region to use can \r\nbe specified by the property `aws.mailregion`. If it is not set, the region is derived using the strategy \r\ndefined above for the `AWSClient` annotation.\r\n\r\n## monitoring\r\n\r\nThe monitoring service allows sending statistics to different backends to collect metering data.\r\n\r\n### Backends\r\n\r\nCurrently a logging backend and AWS CloudWatch are supported. To enable the backend put the desired \r\nlibrary on the classpath. Only one backend can be on the classpath simultaneously.\r\n\r\n### Usage\r\n\r\nTo send metrics manually inject the `MetricSender` interface and call the `sendMetric` method. \r\nYou have to supply some coordinates for the metric and the value itself.\r\n\r\nDvalin also provides AspectJ annotations that send metrics automatically.\r\n\r\n* `@ExecutionTime` - method annotation that reports the execution time of the method\r\n\r\n## interconnect\r\n\r\n*coming soon*\r\n\r\n## test\r\n\r\nThe `test` library provides utilities to help in writing test for dvalin based projects. It adds dependencies\r\nto Mockito, JUnit and Concordion.\r\n\r\n### Base class for Mockito unit tests\r\n\r\nThe class `AbstractMockitoTest` configures JUnit to use the Mockito runner and configures the log4j framework\r\nbefore test execution.\r\n\r\n### InjectionUtils\r\n\r\nThe `InjectionUtils` helper class provides methods to inject dependencies into beans. This allows to fill \r\n`@Autowired` annotated fields in unit tests with mocked objects. See the javadoc of the class for further \r\ninformation about the features.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}